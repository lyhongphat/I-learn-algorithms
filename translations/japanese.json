{
	"page_title": "アルゴリズム学習",
	"categories": "アルゴリズムカテゴリー",
	"select_category": "カテゴリーを選択：",
	"arrays_hashing": "配列とハッシュ",
	"two_pointers": "二つのポインタ",
	"stack": "スタック",
	"stack_desc": "スタックは後入れ先出し（LIFO）の原理に基づく基本的なデータ構造です。\n\n**主な操作：**\n- プッシュ：要素をスタックの先頭に追加 (O(1))\n- ポップ：スタックの先頭から要素を削除 (O(1))\n- ピーク/トップ：先頭の要素を参照 (O(1))\n- 空チェック：スタックが空かどうかを確認 (O(1))\n\n**一般的な用途：**\n- 式の評価と構文解析\n- 元に戻す/やり直し操作\n- ブラウザ履歴ナビゲーション\n- 関数呼び出しの管理\n- 深さ優先探索（DFS）の実装\n\n**実用例：**\n- ブラウザの戻るボタン\n- エディタの元に戻す機能\n- コンパイラの構文チェック\n- 電卓の計算処理\n\n**実装の注意点：**\n- 配列または連結リストを基礎構造として使用\n- スタックのオーバーフローとアンダーフローの処理\n- メモリ制限の考慮\n- スタックサイズの追跡",
	"binary_search": "二分探索",
	"sliding_window": "スライディングウィンドウ",
	"linked_list": "連結リスト",
	"trees": "木構造",
	"tries": "トライ木",
	"heap": "ヒープ/優先度付きキュー",
	"backtracking": "バックトラッキング",
	"graphs": "グラフ",
	"advanced_graphs": "高度なグラフ",
	"dp_1d": "1次元動的計画法",
	"dp_2d": "2次元動的計画法",
	"greedy": "貪欲法",
	"intervals": "区間",
	"math_geometry": "数学と幾何学",
	"bit_manipulation": "ビット操作",
	"arrays_hashing_desc": "配列とハッシュはコンピュータサイエンスの基本的なデータ構造と技術です。\n\n**配列：**\n- 連続したメモリ位置に格納された要素のコレクション\n- インデックスを使用した定数時間アクセス\n- ほとんどのプログラミング言語で固定サイズ\n\n**ハッシュ：**\n- データを固定サイズの値にマッピングする技術\n- O(1)の平均ケース検索のためのハッシュテーブルで使用\n- 一般的な実装：HashSet、HashMap/Dictionary",
	"binary_search_desc": "二分探索はソートされた配列で目的の値を見つけるための検索アルゴリズムです。\n\n**特徴：**\n- O(log n)の時間複雑度\n- ソートされた入力が必要\n- 探索区間を半分に分割\n\n**応用：**\n- ソートされた配列での要素検索\n- 数値計算（二分法）\n- 最適化問題",
	"sliding_window_desc": "スライディングウィンドウは配列/文字列の問題を効率的に解くための技法です。\n\n**種類：**\n- 固定サイズのウィンドウ\n- 可変サイズのウィンドウ\n\n**応用：**\n- 最大部分配列和\n- k個の異なる文字を持つ最長部分文字列\n- 文字列中のアナグラムの探索",
	"linked_list_desc": "連結リストはノードに要素を格納する線形データ構造です。\n\n**種類：**\n- 単方向連結リスト\n- 双方向連結リスト\n- 循環連結リスト\n\n**基本操作：**\n- 挿入\n- 削除\n- 走査\n- 反転",
	"trees_desc": "木構造はルートノードと子ノードを持つ階層的なデータ構造です。\n\n**種類：**\n- 二分木\n- 二分探索木（BST）\n- AVL木\n- 赤黒木\n\n**基本操作：**\n- 挿入\n- 削除\n- 走査（中順、先順、後順）\n- 検索",
	"tries_desc": "トライ木は文字列を格納するための木構造で、接頭辞操作に適しています。\n\n**特徴：**\n- 各ノードが1文字を表す\n- ルートからのパスが文字列を表す\n- 効率的な接頭辞操作\n\n**応用：**\n- オートコンプリート\n- スペルチェッカー\n- IPルーティングテーブル",
	"heap_desc": "ヒープはヒープ条件を満たす完全二分木です。\n\n**種類：**\n- 最小ヒープ\n- 最大ヒープ\n\n**応用：**\n- 優先度スケジューリング\n- ダイクストラのアルゴリズム\n- 中央値の検索\n- K個のソート済み配列のマージ",
	"backtracking_desc": "バックトラッキングは異なる解決策を再帰的に試行する問題解決手法です。\n\n**特徴：**\n- 解を段階的に構築\n- 制約を満たさない解を除外\n\n**代表的な問題：**\n- N-クイーン問題\n- 数独ソルバー\n- 組み合わせ和\n- 単語検索",
	"graphs_desc": "グラフは頂点と辺を使用してオブジェクト間の関係を表現します。\n\n**表現方法：**\n- 隣接行列\n- 隣接リスト\n\n**基本アルゴリズム：**\n- BFS（幅優先探索）\n- DFS（深さ優先探索）\n- 最短経路\n- 最小全域木",
	"advanced_graphs_desc": "高度なグラフアルゴリズムは複雑なグラフ問題を解決します。\n\n**アルゴリズム：**\n- ダイクストラのアルゴリズム\n- ベルマン-フォードのアルゴリズム\n- フロイド-ワーシャルのアルゴリズム\n- クラスカルのアルゴリズム\n- プリムのアルゴリズム\n\n**応用：**\n- ネットワークルーティング\n- ソーシャルネットワーク\n- ゲーム理論",
	"dp_1d_desc": "1次元動的計画法は問題をより単純な部分問題に分割して解きます。\n\n**特徴：**\n- 最適部分構造\n- 重複する部分問題\n\n**代表的な問題：**\n- フィボナッチ数列\n- 階段上り\n- 強盗問題\n- 最長増加部分列",
	"dp_2d_desc": "2次元動的計画法は2次元配列を使用して部分問題の解を格納します。\n\n**代表的な問題：**\n- 最長共通部分列\n- 行列連鎖乗算\n- 編集距離\n- ユニークパス",
	"greedy_desc": "貪欲法は各ステップで局所的に最適な選択を行うアルゴリズムです。\n\n**特徴：**\n- 現時点での最適な選択\n- 必ずしも大域的な最適解を得られない\n\n**代表的な問題：**\n- アクティビティ選択\n- ハフマン符号化\n- 分数ナップサック問題\n- 最小コイン問題",
	"intervals_desc": "区間問題は開始点と終了点を持つ範囲や期間を扱います。\n\n**基本操作：**\n- 区間のマージ\n- オーバーラップの検出\n- スケジューリング\n\n**応用：**\n- 会議室スケジューリング\n- タスクスケジューリング\n- リソース割り当て",
	"math_geometry_desc": "数学と幾何学のアルゴリズムは数値問題と空間問題を解決します。\n\n**トピック：**\n- 素数\n- GCD/LCM\n- 幾何計算\n- ベクトル演算\n\n**応用：**\n- 計算幾何学\n- コンピュータグラフィックス\n- 数学モデリング",
	"bit_manipulation_desc": "ビット操作はビットレベルでの演算を扱います。\n\n**基本操作：**\n- AND、OR、XOR\n- ビットシフト\n- ビットの設定/クリア\n\n**応用：**\n- 最適化\n- データ圧縮\n- エラー検出/訂正"
}
